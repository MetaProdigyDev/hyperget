#!/bin/bash

# Define colors for user-friendly output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m' # No color

# Array of colors to cycle through
COLORS=("$RED" "$GREEN" "$YELLOW" "$BLUE" "$CYAN" "$MAGENTA")

# Define the target installation directory and script name
INSTALL_DIR="/usr/local/bin"
SCRIPT_NAME="hyperget"
INSTALL_PATH="$INSTALL_DIR/$SCRIPT_NAME"

# Function to detect available package manager
detect_package_manager() {
    if command -v apt-get &> /dev/null; then
        echo "apt"
    elif command -v dnf &> /dev/null; then
        echo "dnf"
    elif command -v pacman &> /dev/null; then
        echo "pacman"
    elif command -v yum &> /dev/null; then
        echo "yum"
    elif command -v zypper &> /dev/null; then
        echo "zypper"
    elif command -v brew &> /dev/null; then
        echo "brew"
    elif command -v pkg &> /dev/null; then
        echo "pkg"
    elif command -v emerge &> /dev/null; then
        echo "emerge"
    elif command -v pkg_add &> /dev/null; then
        echo "pkg_add"
    elif command -v apk &> /dev/null; then
        echo "apk"
    else
        return 1  # No known package manager found
    fi
}


# Function to install figlet
install_figlet() {
    local manager="$1"
    echo -e "${YELLOW}Installing 'figlet' using $manager...${NC}"
    case "$manager" in
        apt)
            sudo apt-get update && sudo apt-get install -y figlet
            ;;
        dnf)
            sudo dnf install -y figlet
            ;;
        pacman)
            sudo pacman -Sy --noconfirm figlet
            ;;
        yum)
            sudo yum install -y figlet
            ;;
        zypper)
            sudo zypper install -y figlet
            ;;
        brew)
            brew install figlet
            ;;
        pkg)
            sudo pkg install -y figlet
            ;;
        emerge)
            sudo emerge app-misc/figlet
            ;;
        pkg_add)
            sudo pkg_add figlet
            ;;
        apk)
            sudo apk add figlet
            ;;
        *)
            echo -e "${RED}Error: Unsupported package manager '$manager'. Please install 'figlet' manually.${NC}"
            return 1
            ;;
    esac
}

# Check if figlet is installed
if ! command -v figlet &> /dev/null; then
    echo -e "${YELLOW}'figlet' is not installed.${NC}"
    # Detect the package manager
    PACKAGE_MANAGER=$(detect_package_manager)
    if [[ $? -ne 0 ]]; then
        echo -e "${RED}Error: No supported package manager found. Please install 'figlet' manually.${NC}"
        exit 1
    fi
    # Prompt the user to install figlet
    read -p "Do you want to install 'figlet' using $PACKAGE_MANAGER? (Requires sudo) (y/n): " install_figlet_choice
    if [[ "$install_figlet_choice" =~ ^[Yy]$ ]]; then
        install_figlet "$PACKAGE_MANAGER"
        if [[ $? -ne 0 ]]; then
            echo -e "${RED}Failed to install 'figlet'. Please install it manually and rerun the script.${NC}"
            exit 1
        fi
    else
        echo -e "${RED}'figlet' is required to run this script. Exiting.${NC}"
        exit 1
    fi
fi


# Define the source of the autocomplete file (adjust this if your file is elsewhere)
AUTOCOMPLETE_FILE_SOURCE="$(dirname "$SCRIPT_PATH")/${SCRIPT_NAME}_autocomplete"

# Bash and Zsh autocomplete directories
BASH_COMPLETION_DIR="/etc/bash_completion.d"
ZSH_COMPLETION_DIR="/usr/share/zsh/site-functions"

# Define autocomplete file paths
AUTOCOMPLETE_FILE_BASH="${BASH_COMPLETION_DIR}/${SCRIPT_NAME}_autocomplete"
AUTOCOMPLETE_FILE_ZSH="${ZSH_COMPLETION_DIR}/_${SCRIPT_NAME}"
# Get the current script's full path
SCRIPT_PATH="$(readlink -f "$0" 2>/dev/null || realpath "$0" 2>/dev/null || echo "$0")"

# Get the installed path of the script, if it exists
INSTALLED_PATH="$(command -v "$SCRIPT_NAME" 2>/dev/null || echo "")"

# Function to install autocomplete file for Bash
install_bash_autocomplete() {
    echo -e "${YELLOW}Installing Bash autocomplete file...${NC}"

    if [[ -f "$AUTOCOMPLETE_FILE_SOURCE" ]]; then
        sudo cp "$AUTOCOMPLETE_FILE_SOURCE" "$AUTOCOMPLETE_FILE_BASH"
        sudo chmod +x "$AUTOCOMPLETE_FILE_BASH"
        echo -e "${GREEN}Bash autocomplete installed at '$AUTOCOMPLETE_FILE_BASH'.${NC}"
    else
        echo -e "${RED}Error: Autocomplete file '$AUTOCOMPLETE_FILE_SOURCE' not found.${NC}"
        exit 1
    fi
}

# Function to install autocomplete file for Zsh
install_zsh_autocomplete() {
    echo -e "${YELLOW}Installing Zsh autocomplete file...${NC}"

    if [[ -f "$AUTOCOMPLETE_FILE_SOURCE" ]]; then
        sudo cp "$AUTOCOMPLETE_FILE_SOURCE" "$AUTOCOMPLETE_FILE_ZSH"
        sudo chmod +x "$AUTOCOMPLETE_FILE_ZSH"
        echo -e "${GREEN}Zsh autocomplete installed at '$AUTOCOMPLETE_FILE_ZSH'.${NC}"
    else
        echo -e "${RED}Error: Autocomplete file '$AUTOCOMPLETE_FILE_SOURCE' not found.${NC}"
        exit 1
    fi
}

# Detect the current shell
detect_shell() {
    if [[ "$SHELL" == */bash ]]; then
        echo "bash"
    elif [[ "$SHELL" == */zsh ]]; then
        echo "zsh"
    else
        echo "unknown"
    fi
}

# Install autocomplete based on the detected shell
install_autocomplete() {
    current_shell=$(detect_shell)

    case "$current_shell" in
        bash)
            install_bash_autocomplete
            ;;
        zsh)
            install_zsh_autocomplete
            ;;
        *)
            echo -e "${RED}Unsupported shell: $current_shell. Autocomplete is only supported for Bash and Zsh.${NC}"
            exit 1
            ;;
    esac
}

# Reinstallation should only happen if the -r flag is passed
if [[ "$1" == "-r" ]]; then
    if [[ -n "$INSTALLED_PATH" && "$SCRIPT_PATH" != "$INSTALLED_PATH" ]]; then
        echo -e "${YELLOW}The script '$SCRIPT_NAME' is already installed at '$INSTALLED_PATH'.${NC}"
        read -p "Would you like to reinstall it? (y/n): " reinstall_choice
        if [[ "$reinstall_choice" =~ ^[Yy]$ ]]; then
            if sudo -v &> /dev/null; then
                echo -e "${GREEN}Reinstalling '$SCRIPT_NAME' to '$INSTALL_DIR'...${NC}"
                sudo cp "$SCRIPT_PATH" "$INSTALL_PATH"
                sudo chmod +x "$INSTALL_PATH"
                echo -e "${GREEN}Successfully reinstalled '$SCRIPT_NAME' to '$INSTALL_DIR'.${NC}"

                # Install autocomplete for Bash and Zsh
                install_bash_autocomplete
                install_zsh_autocomplete
            else
                echo -e "${RED}Error: You need sudo permissions to reinstall this script.${NC}"
                exit 1
            fi
        else
            echo -e "${GREEN}Skipping reinstallation.${NC}"
        fi
        exit 0
    else
        echo -e "${RED}Error: Script is not installed, cannot reinstall.${NC}"
        exit 1
    fi
fi

# Check if it's already installed
if [[ -z "$INSTALLED_PATH" ]]; then
    read -p "Do you want to install it to '$INSTALL_DIR'? (Requires sudo) (y/n): " install_choice
    if [[ "$install_choice" =~ ^[Yy]$ ]]; then
        if sudo -v &> /dev/null; then
            echo -e "${GREEN}Installing '$SCRIPT_NAME' to '$INSTALL_DIR'...${NC}"

            # Ensure /usr/local/bin exists
            if [[ ! -d "$INSTALL_DIR" ]]; then
                echo -e "${RED}Error: Directory '$INSTALL_DIR' does not exist. Please create it first.${NC}"
                exit 1
            fi

            # Copy the script and set permissions
            if sudo cp "$SCRIPT_PATH" "$INSTALL_PATH"; then
                sudo chmod +x "$INSTALL_PATH"
                echo -e "${GREEN}Successfully installed '$SCRIPT_NAME' to '$INSTALL_DIR'.${NC}"
                echo -e "${GREEN}You can now run '$SCRIPT_NAME' from any directory.${NC}"

                # Install autocomplete for Bash and Zsh
                install_bash_autocomplete
                install_zsh_autocomplete
            else
                echo -e "${RED}Error: Failed to copy script to '$INSTALL_PATH'.${NC}"
                exit 1
            fi
        else
            echo -e "${RED}Error: You need sudo permissions to install this script.${NC}"
            exit 1
        fi
    else
        echo -e "${YELLOW}Installation skipped.${NC}"
    fi
else
    echo -e "${GREEN}Script is already installed at '$INSTALLED_PATH'.${NC}"

    # Install the autocomplete files if they're not already installed
    if [[ ! -f "$AUTOCOMPLETE_FILE_BASH" ]]; then
        install_bash_autocomplete
    fi
    if [[ ! -f "$AUTOCOMPLETE_FILE_ZSH" ]]; then
        install_zsh_autocomplete
    fi
fi

# --- Multi-colored Figlet Output ---
# Show colorful figlet output at the start of the script

figlet_output=$(figlet -f slant "Hyperget")
footer="by MetaProdigyDev"

# Split figlet output by lines
IFS=$'\n' read -rd '' -a lines <<<"$figlet_output"

# Loop through each line and colorize
for i in "${!lines[@]}"; do
    color=${COLORS[$((i % ${#COLORS[@]}))]}  # Cycle through colors
    echo -e "${color}${lines[$i]}${NC}"      # Print each line in a different color
done

# Print the footer aligned under the last line
last_line_length=${#lines[-1]}  # Get length of the last line
padding=$(( last_line_length - ${#footer} ))  # Calculate padding

# Print the footer with appropriate padding for alignment
if (( padding > 0 )); then
    printf "%${padding}s%s\n" "" "$footer"  # Print the footer with padding
else
    echo "$footer"  # Print footer without padding if it's wider than the last line
fi
# Failsafe: Ensure Flathub remote is added silently
flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo &>/dev/null

# Define the spinner function

function _spinner() {
    # $1 start/stop
    #
    # on start: $2 display message
    # on stop : $2 process exit status
    #           $3 spinner function pid (supplied from stop_spinner)

    local on_success="DONE"
    local on_fail="FAIL"
    local white="\e[1;37m"
    local green="\e[1;32m"
    local red="\e[1;31m"
    local nc="\e[0m"

    case $1 in
        start)
            # calculate the column where spinner and status msg will be displayed
            let column=$(tput cols)-${#2}-8
            # display message and position the cursor in $column column
            echo -ne ${2}
            printf "%${column}s"

            # start spinner
            i=1
            sp='\|/-'
            delay=${SPINNER_DELAY:-0.15}

            while :
            do
                printf "\b${sp:i++%${#sp}:1}"
                sleep $delay
            done
            ;;
        stop)
            if [[ -z ${3} ]]; then
                echo "spinner is not running.."
                exit 1
            fi

            kill $3 > /dev/null 2>&1

            # inform the user uppon success or failure
            echo -en "\b["
            if [[ $2 -eq 0 ]]; then
                echo -en "${green}${on_success}${nc}"
            else
                echo -en "${red}${on_fail}${nc}"
            fi
            echo -e "]"
            ;;
        *)
            echo "invalid argument, try {start/stop}"
            exit 1
            ;;
    esac
}

function start_spinner {
    # $1 : msg to display
    _spinner "start" "${1}" &
    # set global spinner pid
    _sp_pid=$!
    disown
}

function stop_spinner {
    # $1 : command exit status
    _spinner "stop" $1 $_sp_pid
    unset _sp_pid
}
# Check if no arguments were passed
if [[ $# -eq 0 ]]; then
    echo -e "${YELLOW}Usage:${NC} $SCRIPT_NAME search <package_name>"
    echo -e "${YELLOW}       ${NC} $SCRIPT_NAME remove <package_name>"
    echo -e "${YELLOW}       ${NC} $SCRIPT_NAME -i <package_name> (manual install)"
    echo -e "This tool searches, removes, or installs packages across multiple package managers (apt, dnf, pacman, flatpak, snap, brew)"
    exit 0
fi


# Redefine fancy_spinner to use the new spinner logic
fancy_spinner() {
    local pid=$1  # Get the PID of the process to wait for

    start_spinner "Searching Database..."  # Start the spinner with a message
    wait $pid  # Wait for the long-running task to finish
    stop_spinner $?  # Stop the spinner and show success/failure based on exit status
}

# Detect primary package manager based on the distribution or OS
detect_package_manager() {
    if [[ "$OSTYPE" == "darwin"* ]]; then
        echo "brew" # macOS uses Homebrew
    elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
        if [ -f /etc/debian_version ]; then
            echo "apt"
        elif [ -f /etc/fedora-release ]; then
            echo "dnf"
        elif [ -f /etc/arch-release ]; then
            echo "pacman"
        elif [ -f /etc/SuSE-release ]; then
            echo "zypper"
        elif [ -f /etc/redhat-release ]; then
            echo "yum"
        elif command -v nix &> /dev/null; then
            echo "nix"
        elif command -v guix &> /dev/null; then
            echo "guix"
        elif command -v emerge &> /dev/null; then
            echo "portage"
        else
            echo "unknown"
        fi
    elif [[ "$OSTYPE" == "msys" || "$OSTYPE" == "cygwin" || "$OSTYPE" == "win32" ]]; then
        if command -v winget &> /dev/null; then
            echo "winget"
        elif command -v choco &> /dev/null; then
            echo "chocolatey"
        elif command -v scoop &> /dev/null; then
            echo "scoop"
        else
            echo "unknown"
        fi
    else
        echo "unknown"
    fi
}

# Check if a package manager is installed
is_installed() {
    if command -v "$1" &> /dev/null; then
        return 0
    else
        return 1
    fi
}

search_package_exact() {
    local package_name="$1"
    local manager="$2"
    case $manager in
        apt)
            apt-cache search --names-only "^$package_name\$" 2>/dev/null | head -n 1
            ;;
        dnf)
            dnf list available "$package_name" 2>/dev/null | grep -E "^$package_name\." | head -n 1
            ;;
        pacman)
            pacman -Ss "^$package_name\$" | head -n 1
            ;;
        flatpak)
            flatpak search "$package_name" | grep -v "Application ID" | head -n 5
            ;;
        snap)
            snap find "$package_name" | awk 'NR>1 {printf "%s - %s\n", $1, substr($0, index($0,$2))}' | head -n 1
            ;;
        brew)
            # Perform a search
            search_results=$(brew search "$package_name")
            if [[ -z "$search_results" || "$search_results" == *"No formulae or casks found for"* ]]; then
                # Do nothing if no results found
                return 0
            else
                # Get detailed info for found packages
                brew info --json=v1 $search_results | jq -r '.[] | .name + " - " + (.desc // "No description available")' | head -n 5
            fi
            ;;
        *)
            return 1
            ;;
    esac
}


# Fallback search for partial matches in each package manager
search_package_partial() {
    local package_name="$1"
    local manager="$2"
    case $manager in
        apt)
            apt-cache search "$package_name" 2>/dev/null | head -n 5
            ;;
        dnf)
            dnf search "$package_name" 2>/dev/null | head -n 5
            ;;
        pacman)
            pacman -Ss "$package_name" | head -n 5
            ;;
        flatpak)
            flatpak search "$package_name" | grep -v "Application ID" | head -n 5
            ;;
        snap)
            snap find "$package_name" | awk 'NR>1 {print $1}' | head -n 5

            ;;
        brew)
            # Perform a search
            search_results=$(brew search "$package_name")
            if [[ -z "$search_results" || "$search_results" == *"No formulae or casks found for"* ]]; then
                # Do nothing if no results found
                return 0
            else
                # Get detailed info for found packages
                brew info --json=v1 $search_results | jq -r '.[] | .name + " - " + (.desc // "No description available")' | head -n 5
            fi
            ;;
        *)
            return 1
            ;;
    esac
}

# Search packages across all available package managers
search_packages() {
    local package_name="$1"
    declare -A found_packages
    local global_index=1

    echo -e "${GREEN}Searching for package: ${NC}$package_name"
    sleep 1 & fancy_spinner

    # Check all possible package managers
    for manager in apt dnf pacman flatpak snap brew; do
        if is_installed "$manager"; then
            # Attempt exact match search first
            exact_match=$(search_package_exact "$package_name" "$manager")
            if [ -n "$exact_match" ]; then
                found_packages[$manager]="$exact_match"
            else
                # If no exact match, use partial match search
                partial_matches=$(search_package_partial "$package_name" "$manager")
                [ -n "$partial_matches" ] && found_packages[$manager]="$partial_matches"
            fi
        fi
    done

    # Handle results
    if [ ${#found_packages[@]} -eq 0 ]; then
        echo -e "${RED}No packages found matching '$package_name'.${NC}"
        exit 1
    else
        display_results_and_select_package found_packages
    fi
}

# Display search results and allow package selection
display_results_and_select_package() {
    declare -n packages=$1
    declare -A results package_managers

    echo -e "${GREEN}Packages found:${NC}"

    colors=("$CYAN" "$MAGENTA" "$YELLOW" "$BLUE")
    color_index=0

    local global_index=1
    for manager in "${!packages[@]}"; do
        echo -e "${GREEN}${manager}:${NC}"
        IFS=$'\n' read -r -a package_list <<< "${packages[$manager]}"

        for line in "${package_list[@]}"; do
            color=${colors[$color_index]}
            echo -e "${color}  $global_index) $line${NC}"
            results[$global_index]="$line"
            package_managers[$global_index]="$manager"
            global_index=$((global_index + 1))
            color_index=$(( (color_index + 1) % ${#colors[@]} ))
        done
    done

    # Prompt for package selection
    while true; do
        read -p "Select the package to install (1-$((global_index - 1))): " choice
        if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le $((global_index - 1)) ]; then
            selected_package="${results[$choice]}"
            selected_manager="${package_managers[$choice]}"
            break
        else
            echo -e "${RED}Invalid choice.${NC} Please enter a number from 1 to $((global_index - 1))."
        fi
    done

    selected_package_name=$(extract_package_name "$selected_package" "$selected_manager")

    if is_package_installed "$selected_package_name" "$selected_manager"; then
        echo -e "${YELLOW}Package '$selected_package_name' is already installed from $selected_manager.${NC}"
        read -p "Do you want to remove it? (y/n): " remove_choice
        if [[ "$remove_choice" == "y" ]]; then
            remove_package "$selected_package_name" "$selected_manager"
        else
            echo -e "${GREEN}Keeping '$selected_package_name' installed from $selected_manager.${NC}"
            exit 0
        fi
    else
        install_package "$selected_package_name" "$selected_manager"
    fi
}
# Extract package name from the selected package entry (for correct installation)
extract_package_name() {
    local package_line="$1"
    local manager="$2"

    case $manager in
        apt)
            echo "$package_line" | awk '{print $1}'  # Only the first word (package name)
            ;;
        dnf)
            echo "$package_line" | awk '{print $1}'  # Only the first word (package name)
            ;;
        pacman)
            echo "$package_line" | awk '{print $1}'  # Only the first word (package name)
            ;;
        flatpak)
            # Extract only the Application ID (third field, skipping other metadata)
            echo "$package_line" | awk '{print $3}' | grep '\.'  # Ensure it's a valid Application ID (contains a dot)
            ;;
        snap)
            echo "$package_line" | awk '{print $1}'  # Only the first word (package name)
            ;;
        brew)
            echo "$package_line" | awk '{print $1}'  # Only the first word (package name)
            ;;
        *)
            return 1
            ;;
    esac
}




# Check if a package is already installed
is_package_installed() {
    local package_name="$1"
    local manager="$2"
    case $manager in
        apt)
            dpkg -l | grep -qw "$package_name"
            ;;
        dnf)
            dnf list installed "$package_name" &>/dev/null
            ;;
        pacman)
            pacman -Qs "$package_name" &>/dev/null
            ;;
        flatpak)
            flatpak list --app | awk '{print $1}' | grep -qw "$package_name"
            ;;
        snap)
            snap list | awk '{print $1}' | grep -qw "$package_name"
            ;;
        brew)
            brew list --formula | grep -qw "$package_name"
            ;;
        *)
            return 1
            ;;
    esac
}

# Install the package
install_package() {
    package_name="$1"
    package_manager="$2"
    echo -e "${GREEN}Installing package: $package_name from $package_manager...${NC}"

    case $package_manager in
        apt)
            sudo apt update -y && sudo apt install -y "$package_name"
            ;;
        dnf)
            sudo dnf install -y "$package_name"
            ;;
        pacman)
            sudo pacman -S --noconfirm "$package_name"
            ;;
        flatpak)
            flatpak install -y flathub "$package_name"
            ;;
        snap)
            sudo snap install "$package_name"
            ;;
        brew)
            brew install "$package_name"
            ;;
        *)
            echo -e "${RED}Unknown package manager.${NC}"
            exit 1
            ;;
    esac

    if [ $? -eq 0 ]; then
        echo -e "${GREEN}Success! Package '$package_name' installed.${NC}"
    else
        echo -e "${RED}Error: Installation failed.${NC}"
    fi
}

# Remove a package
remove_package() {
    package_name="$1"
    package_manager="$2"
    echo -e "${GREEN}Removing package: $package_name from $package_manager...${NC}"

    case $package_manager in
        apt)
            sudo apt remove -y "$package_name"
            ;;
        dnf)
            sudo dnf remove -y "$package_name"
            ;;
        pacman)
            sudo pacman -Rns "$package_name"
            ;;
        flatpak)
            flatpak uninstall -y "$package_name"
            ;;
        snap)
            sudo snap remove "$package_name"
            ;;
        brew)
            brew uninstall "$package_name"
            ;;
        *)
            echo -e "${RED}Unknown package manager.${NC}"
            exit 1
            ;;
    esac

    if [ $? -eq 0 ]; then
        echo -e "${GREEN}Success! Package '$package_name' removed.${NC}"
    else
        echo -e "${RED}Error: Removal failed.${NC}"
    fi
}

# Main script logic with help and usage instructions
if [[ "$1" == "--help" || "$1" == "-h" ]]; then
    echo -e "${YELLOW}Usage:${NC} $SCRIPT_NAME search <package_name>"
    echo -e "${YELLOW}       ${NC} $SCRIPT_NAME remove <package_name>"
    echo -e "${YELLOW}       ${NC} $SCRIPT_NAME -i <package_name> (manual install)"
    echo -e "This tool searches, removes, or installs packages across multiple package managers (apt, dnf, pacman, flatpak, snap, brew)"
    exit 0
elif [[ "$1" == "search" && -n "$2" ]]; then
    search_packages "$2"
elif [[ "$1" == "remove" && -n "$2" ]]; then
    package_manager=$(detect_package_manager)
    if [[ "$package_manager" == "unknown" ]]; then
        echo -e "${RED}Error: Unable to detect a compatible package manager for removal.${NC}"
        exit 1
    fi
    remove_package "$2" "$package_manager"
elif [[ "$1" == "-i" && -n "$2" ]]; then
    package_manager=$(detect_package_manager)
    if [[ "$package_manager" == "unknown" ]]; then
        echo -e "${RED}Error: Unable to detect a compatible package manager for installation.${NC}"
        exit 1
    fi
fi
